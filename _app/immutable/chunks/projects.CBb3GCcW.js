import{A as t}from"./assets.C14Re_Fe.js";import{a as i}from"./skills.B0zLjE04.js";import{b as e}from"./paths.Dts6URvz.js";const s=[{slug:"cerebral-aneurysm",color:"#5e95e3",description:"This a deep learning system for detecting and segmenting intracranial cerebral aneurysms in Time-of-Flight Magnetic Resonance Angiography (TOF-MRA). We used a 3D U-Net architecture, weak (spherical) labels and incorporated anatomically informed sliding windows. Our intelligent patch selection strategy guided by vascular anatomy helped the model focus on the most high-probabilty regions, significantly improving efficiency and accuracy. We also optimized the pipeline's memory usage—reducing the training footprint by over 40%—through custom TensorFlow operations and efficient data loading. We were able to achieve a 0.76 Dice score and 83% sensitivity on the test set, demonstrating the model's effectiveness in identifying aneurysms in complex 3D MRA volumes.",shortDescription:"This a deep learning system for detecting and segmenting cerebral aneurysms in Time-of-Flight Magnetic Resonance Angiography",links:[{to:"https://github.com/ecbme6040/e6691_2025spring_Project_ABAD_kb3343_mmk2266",label:"GitHub"},{to:"https://drive.google.com/file/d/1A583KvoxQYENKU4906acYr8Om4b7Dzmf/view",label:"Paper"}],logo:t.Aneurysm,name:"Cerebral Aneurysm Segmentation in TOF-MRA",skills:i("py","tensorflow","gcp"),type:"Deep Learning Model",screenshots:[{label:"Output Segmentation (Axial View)",src:`${e}/screenshots/axial.png`},{label:"Output Segmentation (Sagittal View)",src:`${e}/screenshots/saggital.png`},{label:"UNet Architecture",src:`${e}/screenshots/unet.png`}]},{slug:"tcp",color:"black",description:"This is a custom implementation of a transport-layer protocol (TCP) designed for reliable data transfer over an unstable, simulated network prone to packet loss and bit corruption. It features sliding window flow control, segment retransmission, and hashed checksums for integrity. Stateful connection handling is implemented with a three-way handshake, robust timeout logic, and clean termination procedures. The system uses multithreading on both client and server sides—one thread manages incoming messages into a buffer, while others handle connection state. The core components include mrt_server.py (server-side connect, send, close logic), mrt_client.py (client-side accept, receive, close logic), segment.py (for segment construction and parsing), and network.py (a loss-prone network simulator). Key protocol elements include sequenced data segments for in order delivery, ACKs, sliding window-based flow control, timeout-triggered retransmissions, and FIN resend mechanisms for reliable termination.",shortDescription:"This is a custom implementation of a transport-layer protocol (TCP) designed for reliable data transfer",links:[{to:"https://github.com/kabirbagai21/Custom_RTP_Implementation",label:"GitHub"}],logo:t.TCP,name:"Reliable Transport Protocol Implementation",skills:i("py","shell"),type:"Network Programming",screenshots:[{label:"Example Test Case 1",src:`${e}/screenshots/synack.png`},{label:"Example Test Case 2",src:`${e}/screenshots/segcontrol.png`}]},{slug:"traffic-detection",color:"orange",description:"This project uses a dataset of images of street traffic captured at the Amsterdam Ave. and 120th Street intersection. The goal was to build a model that can effectively identify rare classes and situations that have the potential to disrupt traffic flow or cause harm to pedestrians (barricades, emergency vehicles, traffic cones etc). This task is more challenging than typical image classification tasks due to the complexity of the images, limited dataset size (100 training images), and severe class imbalance. We initially tried to train CNNs and vision transformers but due to the aforementioned issues, we achieved poor performance with these single modality models. We then decided to try a zero-shot vison language model. By leveraging the pre-trained, Recognize Anything Model (RAM) and adapting it for our needs, we achieved a classification performance of 0.716 on the test set, the highest score on the Kaggle in-class competition.",shortDescription:"This project uses a dataset of images of street traffic captured at the Amsterdam Ave. and 120th Street intersection. The goal is to build a model that can effectively identify rare",links:[{to:"https://github.com/kabirbagai21/traffic_disruption_detection",label:"GitHub"},{to:"https://drive.google.com/file/d/1m2p37F_YhCSSonPSIXPIVtfj9LtXZFst/view?usp=sharing",label:"Paper"}],logo:t.Traffic,name:"Traffic Disruption Detection with Zero-Shot VLM",skills:i("py","tensorflow","gcp"),type:"Deep Learning Model",screenshots:[{label:"Example Image",src:`${e}/screenshots/streetview.jpg`},{label:"Model Accuracies",src:`${e}/screenshots/ram_accuracies.png`}]},{slug:"study-buddy",color:"purple",description:"Study Buddy is a full-stack web application built with the Ruby on Rails framework to enable collaboration and networking among students in the same class. The app allows users to form study groups, coordinate on homework, and connect for group projects, offering a novel platform for academic teamwork. In addition to building core backend features and API endpoints, I served as SCRUM master, setting sprint goals, coordinating task ownership, and ensuring smooth integration across the frontend, backend, and deployment pipeline. Under my leadership, our team successfully delivered four releases, culminating in a fully functional and polished live application.",shortDescription:"Study Buddy is a full-stack web application built with the Ruby on Rails framework to enable collaboration and networking among students in the same class.",links:[{to:"https://github.com/kabirbagai21/studdybuddyproject",label:"GitHub"}],logo:t.StuddyBuddy,name:"Study Buddy",skills:i("ruby-on-rails","heroku"),type:"Full Stack Web App",videos:[{label:"Demo",src:"https://www.youtube.com/watch?v=PuXueC5JVNc"}]},{slug:"robotics",color:"yellow",description:"As part of my computational robotics course, I implemented and deployed motion planning algorithms, including A*, LPA*, and Rapidly-Exploring Random Trees (RRT), to enable autonomous navigation in complex, dynamic environments. To support accurate localization and mapping, I explored state estimation techniques such as Particle Filters, Kalman Filters, and EKF-SLAM, achieving fast and stable convergence. In a simulated environment, I also integrated computer vision and machine learning techniques for real-time collision detection and developed inverse kinematics solutions for precise manipulation of the KUKA iiwa robotic arm. ",shortDescription:"Implementations of various robotics algorithms, including path planning, localization, kinematics and mapping in simulated environments.",links:[{to:"https://github.com/kabirbagai21/comp_robotics",label:"GitHub"}],logo:t.Robot,name:"Robotics Algorithms",skills:i("py","jupyter","opencv"),type:"Robotics",screenshots:[{label:"RRT",src:`${e}/screenshots/rrt.png`},{label:"Collision Detection",src:`${e}/screenshots/collision.png`},{label:"LPA* Path Planning",src:`${e}/screenshots/lpa.png`},{label:"Inverse Kinematics using GD",src:`${e}/screenshots/ikgd.png`}],videos:[{label:"Particle Filter",src:`${e}/screenshots/particle_filter.mp4`},{label:"EKF SLAM",src:`${e}/screenshots/ekf_slam.mp4`}]},{slug:"receipt-chain",color:"green",description:"A decentralized application for secure receipt management and automated escrow services using blockchain technology. The system enables sellers to issue digital receipts and manages funds in escrow, with automated release mechanisms and return functionality. We built the smart contracts in Solidity and deployed them on a simulated ethereum blockchain using Truffle and Ganache to emulate real-world buyer-seller scenarios. The backend was built with Flask and FastAPI to access endpoints and DynamoDB for data storage, while the frontend was developed using ReactJS.",shortDescription:"A decentralized application for secure receipt management and automated escrow services using blockchain technology.",links:[{to:"https://github.com/AmieRamie/COMS-6998-Blockchain-Project-Backend",label:"GitHub"}],logo:t.Ethereum,name:"ReceiptChain",skills:i("solidity","flask","fastapi","dynamo","reactjs"),type:"Blockchain App",screenshots:[{label:"Onboarding Flow",src:`${e}/screenshots/userflow.png`},{label:"Endpoints",src:`${e}/screenshots/endpoints.png`},{label:"Smart Contracts",src:`${e}/screenshots/smartcontracts.png`}]},{slug:"chatbot",color:"cyan",description:"This project is a multi-client chat server written in C using low-level POSIX socket programming (TCP) and I/O multiplexing with select() to support real-time communication between multiple clients. The server handles all connected clients in a single-threaded, event-driven loop, efficiently monitoring incoming messages and broadcasting them to all other connected users. Clients connect via TCP and support interactive input via stdin, allowing users to send messages to the server in real-time. The server acts as a relay, receiving messages from clients and broadcasting them to all other active clients.",shortDescription:"This project is a multi-client chat server written in C using low-level POSIX socket programming.",links:[{to:"https://github.com/kabirbagai21/chatbot",label:"GitHub"}],logo:t.Chat,name:"Chat Server",skills:i("C","shell"),type:"Systems Programming",screenshots:[]}],n="Projects",l={title:n,items:s};export{l as P};
